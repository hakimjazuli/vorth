class U{static webComponentGlobalStyles=[];static literal=(z,...J)=>{let X=[];for(let Y=0;Y<z.length;Y++)if(X.push(z[Y]),Y<J.length)X.push(J[Y]);return X.join("")};static debounce=0;static removeDOM$="virst-rm-dom$";static val="virst-a-val";static classes="virst-a-class";static toValidClassNames=(z)=>z.replace(/[^a-zA-Z0-9]+/g," ").trim().split(" ");static qRouteChange="virst-qrc";static docScopeElement="virst-sc";static storageIdentifier="virst-st";static DCCBIdentifier="virst-dc";static ACCBIdentifier="virst-ac";static onViewCBIdentifier="virst-ov";static onExitViewCBIdentifier="virst-oxv";static templatePrefix="virst-template";static keptElement="virst-keep";static ForQPrefix="virst-fq-";static ForChildAttributePrefix="virst-fc-";static warningSingleton=(z)=>{console.warn({class:z,message:"is a singleton class, and can only be instantiated once"})};static uniqueID_=new Set;static get uniqueID(){let z=Math.floor(Math.random()*1000000000000000),J=`${Date.now()}${z}`;if(U.uniqueID_.has(J))return U.uniqueID;return U.uniqueID_.add(J),setTimeout(()=>{U.uniqueID_.delete(J)},100),J}static currentDocumentScope_=void 0;static get currentDocumentScope(){if(U.currentDocumentScope_===void 0)U.currentDocumentScope_=document;return U.currentDocumentScope_}static set currentDocumentScope(z){U.currentDocumentScope_=z}static attrPrefix="virst-ap-";static attributeIndexGenerator=(z=!1)=>{if(U.currentDocumentScope==document&&!z)return null;return`${U.attrPrefix}${U.uniqueID}`};static timeout=(z)=>new Promise((J)=>setTimeout(J,z));static splitX=(z,J)=>{let X=[],Y="",Z=!1;for(let K=0;K<z.length;K++){let G=z[K];if(Z)Y+=G,Z=!1;else if(G==="\\")Z=!0;else if(G===J)X.push(Y),Y="";else Y+=G}return X.push(Y),X};static separator=";";static isAsync=(z)=>z.constructor.name==="AsyncFunction";static validAttributeNameSelector=(z)=>z.toLowerCase().replace(/:/g,"\\:");static handlePromiseAll=async(z,J,...X)=>{if(!J)return;await Promise.all(J.map(async(Y)=>{try{await Y(...X)}catch(Z){console.error({callback:Y,source:z,message:"Error in callback",error:Z})}})).catch((Y)=>{console.error({asyncArrayFunctions:J,source:z,message:"Promise.all failed:",error:Y})})}}var L=window.virst=window.virst??{};class C{static assign_=(z)=>{if(this.push(z),!C.isRunning)this.run()};static{L.QFIFO=L.QFIFO??C.assign_}constructor(){}static queue=[];static isRunning=!1;static assign=L.QFIFO;static push=(z)=>{this.queue.push(z.details)};static run=async()=>{C.isRunning=!0;while(this.queue.length!==0){let[z,J]=this.queue[0];if(this.queue.shift(),J)await U.timeout(J);await z()}C.isRunning=!1}}class f{details;constructor(z,J=0){this.details=[z,J]}}class y{static assign_=(z)=>{if(this.push(z),!this.isRunning)this.run()};static{L.QUnique=L.QUnique??y.assign_}static queue=new Map;static isRunning=!1;static assign=L.QUnique;static push=(z)=>{let{callback:J,debounce:X,id:Y}=z;this.queue.set(Y,[J,X?X:0])};static run=async()=>{this.isRunning=!0;let z=this.queue.keys(),J=z.next();while(!J.done){let X=J.value,[Y,Z]=this.queue.get(X);this.queue.delete(X),await U.timeout(Z),await Y(),J=z.next()}this.isRunning=!1}}class h{constructor(z,J,X=0){this.id=z,this.callback=J,this.debounce=X}id;callback;debounce}class F{asyncCallback;constructor(z,J,X={fifo:!0}){if(this.asyncCallback=J,z){if("fifo"in X)this.fifo(!0);if("unique"in X)this.unique(X.unique,!0)}}fifo=(z=!1)=>{C.assign(new f(async()=>{await this.asyncCallback(z)},U.debounce))};static get isRunning(){return C.isRunning}unique=(z,J=!1)=>{y.assign(new h(z,async()=>{await this.asyncCallback(J)},U.debounce))}}class q{static domReflector=(z,J,X,Y)=>{let Z=U.splitX(X.getAttribute(J)??"",U.separator);for(let K=0;K<Z.length;K++){let G=Z[K];if(G==="")continue;try{if(!(G in X))throw Error();if(X[G]=z,X.parentElement&&G==="value"&&"value"in X&&"oninput"in X&&!X.hasAttribute(U.val))X.setAttribute(U.val,""),X.oninput=()=>{new F(!0,async()=>{Y.value=X.value})}}catch(W){if(X.parentElement&&G==="class"){let Q=X[U.classes]??[];if(z===null||!("class"in z))continue;try{let x=U.toValidClassNames(z.class);if(x.join(",")===Q.join(","))continue;let M=Math.max(x.length,Q.length);for(let R=0;R<M;R++){let O=Q[R];if(O)X.classList.remove(O);let $=x[R];if($)X.classList.add($)}X[U.classes]=x}catch(x){console.warn({signal:this,value:z,attr:J,error:x,cause:"signal value incorrectly formatted",validFormat:{class:"string of classNames separated by spaces"}})}continue}if(z=JSON.stringify(z).replace(/^"(.*)"$/,"$1"),G==""){console.warn({error:W,element:X,attributeName:J,message:"doesn't have target"});return}X.setAttribute(G,z)}}};static dataOnly=(z)=>new q(z);static subscriptions(z){return B.signals.get(z)}removeAll$=()=>{B.effects.forEach((z)=>{z.delete(this)}),q.subscriptions(this).clear(),B.signals.delete(this)};remove$=(z)=>{if(B.effects.has(z.effect))B.effects.get(z.effect).delete(this);q.subscriptions(this).delete(z.effect)};unRef=()=>{this.removeAll$(),this.value_=null,this.attr=null};value_;call$=()=>{new F(!0,async()=>{if(!q.subscriptions(this))return;U.handlePromiseAll(this.call$,Array.from(q.subscriptions(this)),!1)})};constructor(z,J=void 0,X={}){if(this.value_=z,J){this.attr=J;let{documentScope:Y=void 0}=X;I.scopedPing({documentScope:Y,runCheckAtFirst:!0,scopedCallback:async()=>{new I({documentScope:Y,attr:J,onConnected:async({element:Z,onDisconnected:K})=>{let G=new B(async()=>{q.domReflector(this.value,J,Z,this)});Z[U.removeDOM$]=async()=>{if(this.remove$(G),typeof Z.oninput==="function")Z.oninput=null},K(Z[U.removeDOM$])}})}})}}attr=void 0;get value(){if(B.isRegistering)B.letInstances.add(this);return this.value_}set value(z){if(this.value_===z)return;this.value_=z,this.call$()}}class B{static effects=new Map;static signals=new Map;static letInstances=new Set;static isRegistering=!1;remove$=()=>{if(!B.effects.has(this.effect))return;B.effects.get(this.effect).forEach((z)=>{B.signals.get(z).delete(this.effect)}),B.effects.delete(this.effect)};effect;constructor(z){this.effect=z,new F(!0,async()=>{B.isRegistering=!0,await z(!0),B.isRegistering=!1;let J=B.letInstances;B.effects.set(z,new Set(J)),J.forEach((X)=>{if(!B.signals.has(X))B.signals.set(X,new Set);B.signals.get(X).add(z)}),B.letInstances.clear()})}}class A{static __;static chachedTemplate={};constructor({callerAttribute:z,targetAttribute:J,targetPathRule:X=(Y)=>Y}){if(A.__ instanceof A){U.warningSingleton(A);return}A.__=this,A.targetAttribute=J,A.targetPathRule=X,A.callerAttribute=z,new I({attr:z,onConnected:async({element:Y})=>{await this.renderElement({element:Y})}})}static callerAttribute;static targetAttribute;static targetPathRule;swap=(z)=>{this.renderElement(z)};static replace=(z,J,X="inner")=>{switch(X){case"outer":let Y=J[0].cloneNode(!0);z.replaceWith(Y);break;case"inner":default:z.innerHTML=J[1];break}};renderElement=async({element:z,path:J,templateName:X,mode:Y="inner"})=>{if(!J||!X){let W=A.callerAttribute,Q=z.getAttribute(W);if(!Q){console.warn({element:z,callerAttribute:W,message:`attributeName "${W}" must have value to be used as templateSelector`});return}[J,X,Y="inner"]=U.splitX(Q,U.separator)}let Z=A.targetAttribute,K=A.targetPathRule(J),G=await A.fromCache(Z,K,X);A.replace(z,G,Y)};static getDocument=async(z)=>{if(z in this.cachedDocument)return this.cachedDocument[z];let J;try{if(J=await fetch(z),!J.ok)J=await fetch(`${z}.html`);if(!J.ok)throw Error(`Error fetching: status="${J.status}"`);let X=await J.text(),Y=new DOMParser;return this.cachedDocument[z]=Y.parseFromString(X,"text/html")}catch(X){console.error({error:X,response:J})}};static cachedDocument={};static fromCache=async(z,J,X)=>{let Y=A.chachedTemplate[J]?.[X];if(Y)return Y;let Z=await this.getDocument(J),K=Z.querySelectorAll("script");for(let M=0;M<K.length;M++)K[M].remove();A.chachedTemplate[J]={};let G=Z.body;A.chachedTemplate[J].body=[G,G.innerHTML];let W=Z.head;A.chachedTemplate[J].head=[W,W.innerHTML];let Q=Z.querySelectorAll(`[${z}]`),x;for(let M=0;M<Q.length;M++){let R=Q[M],O=R.getAttribute(z);if(!(R instanceof HTMLElement))continue;if(A.chachedTemplate[J][O]=[R,R.innerHTML],O===X)x=R}if(X!=="head"&&X!=="body"&&!x){console.error(`couldn't find '[${z}="${X}"]' in the ${J}`);return}return A.chachedTemplate[J]?.[X]}}var _=L.uniqueVirstQueue=L.uniqueVirstQueue??new Map;class T{static fifo_=Promise.resolve();static fifo=async()=>{let z,J=new Promise((Y)=>{z=Y}),X=T.fifo_;return T.fifo_=J,await X,{resume:()=>{z()}}};static unique=async(z)=>{if(!_.has(z)){_.set(z,Promise.resolve());let J,X=new Promise((Z)=>{J=Z}),Y=_.get(z);return _.set(z,X),await Y,{resume:()=>{J(),_.delete(z)}}}else return await _.get(z),await T.unique(z)}}class E{static get root(){return E.observer.root}static get thresholds(){return E.observer.thresholds}static get rootMargin(){return E.observer.rootMargin}static takeRecords=()=>E.observer.takeRecords();static disconnect=()=>E.observer.disconnect();constructor({element:z,attr:J,onViewPort:X,lifecyclesOnDisconnected:Y}){E.setOnView(z,J,X),E.observer.observe(z);for(let Z=0;Z<Y.length;Z++)Y[Z](async()=>{E.unobserveElement(z,J)})}static getOnView=(z)=>{if(!(z[U.onViewCBIdentifier]instanceof Map))z[U.onViewCBIdentifier]=new Map;return z[U.onViewCBIdentifier]};static setOnView=async(z,J,X)=>{let{resume:Y}=await T.unique(z),Z=E.getOnView(z);if(!Z.has(J))Z.set(J,new Set);Z.get(J).add(X),Y()};static getOnExit=(z)=>{if(!(z[U.onExitViewCBIdentifier]instanceof Map))z[U.onExitViewCBIdentifier]=new Map;return z[U.onExitViewCBIdentifier]};static setOnExit=async(z,J,X)=>{let{resume:Y}=await T.unique(z),Z=E.getOnExit(z);if(!Z.has(J))Z.set(J,new Set);Z.get(J).add(X),Y()};static loadCount_=10;static get loadCount(){return E.loadCount_}static set loadCount(z){if(typeof z==="number"&&z>0)E.loadCount_=z;else console.warn("loadCount must be a positive number. Using the absolute value instead;"),E.loadCount_=Math.abs(z)}static observer=new IntersectionObserver((z)=>{let J=E.loadCount,X=[];for(let Y=0;Y<z.length;Y++){if(X.push(async()=>{await E.handleEntry(z[Y])}),(Y+1)%J!==0)continue;U.handlePromiseAll(E.observer,X),X.length=0}if(X.length>0)U.handlePromiseAll(E.observer,X)},{threshold:[0,0]});static handleEntry=async(z)=>{let J=z.target;if(!(J instanceof HTMLElement))return;let{resume:X}=await T.unique(J),Y=E.getOnView(J),Z=E.getOnExit(J);if(z.isIntersecting){if(Y.size)Y.forEach((K,G)=>{K.forEach(async(W)=>{await W({onExitViewPort:(Q)=>{E.setOnExit(J,G,Q)},removeOnExitCallback:()=>E.removeOnExitCallback(J,G),removeOnViewCallback:()=>E.removeSightCallback(J,G),unobserveElement:()=>E.unobserveElement(J,G)})})});X();return}if(Z.size)Z.forEach((K)=>{K.forEach(async(G)=>{await G()})});X()};static removeSightCallback=(z,J)=>{let X=E.getOnView(z);if(!X.has(J))return;X.get(J).clear(),X.delete(J)};static removeOnExitCallback=(z,J)=>{let X=E.getOnExit(z);if(!X.has(J))return;X.get(J).clear(),X.delete(J)};static unobserveElement=(z,J)=>{E.removeSightCallback(z,J),E.removeOnExitCallback(z,J),this.observer.unobserve(z)}}class I{constructor({onConnected:z,attr:J=U.attributeIndexGenerator(),documentScope:X=U.currentDocumentScope}){new F(!0,async()=>{this.attr=J,this.onConnected=z,this.currentDocumentScope=X;let{mutationObserver:Y,mutationRecordSignal:Z}=I.createObserver(X,J);this.mutationObserver=Y,this.mutationSignal=Z,this.takeRecords=Y.takeRecords;let K=this.isScopeMapped();switch(K){case"newScope":this.effect=new B(async(G)=>{let W=Z.value;if(G){await this.initiator();return}new F(!0,async()=>{await this.mutationHandler(W)},{unique:W})});break;case"addToScope":await this.initiator();break;default:console.error({documentScope:X,message:`'${K}' already registered in this 'documentScope'`,registeredAttributes:Object.keys(I.ID.get(X))});break}})}isScopeMapped=()=>{let z=this.currentDocumentScope;if(!I.ID.has(z))return I.ID.set(z,new Map().set(this.attr,this.onConnected)),"newScope";if(this.attr in I.ID.get(z))return this.attr;return I.ID.get(z).set(this.attr,this.onConnected),"addToScope"};initiator=async()=>{await this.addedNodeHandler(this.currentDocumentScope,this.attr,!0)};attr;static registeredDocumentScope=new Map;static createObserver=(z,J)=>{if(I.registeredDocumentScope.has(z)){let K=I.registeredDocumentScope.get(z);if(!K.attr.has(J))K.attr.add(J);return K}let X=q.dataOnly(""),Y=new MutationObserver((K)=>{X.value=K});Y.observe(z,{childList:!0,subtree:!0,attributes:!0});let Z={mutationObserver:Y,mutationRecordSignal:X,attr:new Set([J])};return I.registeredDocumentScope.set(z,Z),Z};static shallowScope=async({documentScope:z,scopedCallback:J})=>{let X=U.currentDocumentScope;U.currentDocumentScope=z,await J(),U.currentDocumentScope=X};static scopedPing=({documentScope:z,scopedCallback:J,runCheckAtFirst:X})=>new F(X,async()=>{let Y=U.currentDocumentScope;U.currentDocumentScope=z,await J(),U.currentDocumentScope=Y}).fifo;static ID=new Map;currentDocumentScope;disconnect=()=>{if(this.effect)this.mutationSignal.remove$(this.effect);let z=this.currentDocumentScope;if(z!==document)this.mutationObserver.disconnect(),I.ID.delete(z)};takeRecords;mutationSignal;mutationObserver;effect;onConnected;checkValidScoping=(z,J,X)=>{if(J!==X&&J!==document){let Y=I.registeredDocumentScope.get(J);if(Y&&Y.attr.has(z))return!1;if(J.parentElement)return this.checkValidScoping(z,J.parentElement,X)}if(!I.registeredDocumentScope.has(X))return!1;if(!I.registeredDocumentScope.get(X).attr.has(z))return!1;return!0};addedNodeHandler=async(z,J,X)=>{if(X&&"querySelectorAll"in z){let G=U.validAttributeNameSelector(J),W=z.querySelectorAll(`[${G}]`);for(let Q=0;Q<W.length;Q++)await this.addedNodeHandler(W[Q],J,!1)}let Y=this.currentDocumentScope;if(!(z instanceof HTMLElement)||!("hasAttribute"in z)||!z.hasAttribute(J)||!this.checkValidScoping(J,z,Y))return;let Z=I.getDCCB(z);if(Z&&Z.has(J)){let G=[],W=[];Z.get(J).forEach((Q,x)=>{if(x===Y)return;console.warn({warning:"you have `element` with `outOfScope` `attributeName`, the `currentDocumentScope` has the same `attributeName`",attributeName:J,outOfScope:x,currentDocumentScope:Y,LifecycleInstance:this}),G.push(...Array.from(Q)),W.push(x)}),await U.handlePromiseAll(this.addedNodeHandler,G);for(let Q=0;Q<W.length;Q++)Z.get(J).delete(W[Q])}let K=I.ID.get(Y);if(!K||!K.has(J))return;if(z.parentElement){let G=async(W)=>{I.setDCCB(Y,z,J,async()=>{await W()})};K.get(J)({get isConnected(){return z.isConnected},swap:(W)=>{if(!(A instanceof A))return;A.__.swap({element:z,...W})},onViewPort:(W)=>new E({onViewPort:W,element:z,attr:J,lifecyclesOnDisconnected:[G]}),element:z,html:(W,...Q)=>{let x=U.literal(W,...Q);return{inner:()=>{z.innerHTML=x},string:x}},lifecycleObserver:this,onDisconnected:G,onAttributeChanged:(W)=>{I.setACCB(z,J,async(Q)=>{await W(Q)})}})}};static setDCCB=async(z,J,X,Y)=>{let Z=I.getDCCB(J);if(!Z)Z=J[U.DCCBIdentifier]=new Map;if(!Z.has(X))Z.set(X,new Map);let K=Z.get(X);if(!K.has(z))K.set(z,new Set);K.get(z).add(Y)};static getDCCB=(z)=>{if(!(U.DCCBIdentifier in z))return;return z[U.DCCBIdentifier]};static setACCB=(z,J,X)=>{let Y=I.getACCB(z);if(!Y)Y=z[U.ACCBIdentifier]=new Map;if(!Y.has(J))Y.set(J,new Set);Y.get(J).add(X)};static getACCB=(z)=>{if(!(U.ACCBIdentifier in z))return;return z[U.ACCBIdentifier]};callACCB=(z,J)=>{let X=I.getACCB(z);if(!X)return;new F(!0,async()=>{let Y=[];X.forEach(async(Z)=>{Z.forEach((K)=>{Y.push(async()=>{await K({attr:J,newValue:z.getAttribute(J)??""})})})}),await U.handlePromiseAll(this.callACCB,Y)},{unique:z})};mutationHandler=async(z)=>{let J=I.ID.get(this.currentDocumentScope);for(let X=0;X<z.length;X++){let Y=z[X];if(Y.addedNodes)for(let K=0;K<Y.addedNodes.length;K++){let G=Y.addedNodes[K];if(J)J.forEach(async(W,Q)=>{await this.addedNodeHandler(G,Q,!0)})}if(Y.removedNodes)for(let K=0;K<Y.removedNodes.length;K++){let G=Y.removedNodes[K];if(!(G instanceof HTMLElement))continue;await this.mutationDCHandler(G)}if(Y.type!=="attributes")continue;let Z=Y.target;if(Z instanceof HTMLElement&&Y.attributeName)this.callACCB(Z,Y.attributeName)}};removeParentOfNestedLCDCCB=(z)=>{if(I.ID.has(z))z[U.DCCBIdentifier].set("",[async()=>{I.ID.delete(z)}])};mutationDCHandler=async(z)=>{let J=I.findDeepNested(z);new F(!0,async()=>{let X=[];for(let Y=0;Y<J.length;Y++){let Z=J[Y];if(!(Z instanceof HTMLElement))continue;this.removeParentOfNestedLCDCCB(Z);let K=I.getDCCB(Z);if(K)K.forEach((G)=>{G.forEach((W)=>{X.push(...Array.from(W))})})}await U.handlePromiseAll(this.mutationDCHandler,X)},{unique:z})};static findDeepNested=(z,J=[])=>{if(I.getDCCB(z))J.push(z);for(let X=0;X<z.children.length;X++)I.findDeepNested(z.children[X],J);return J}}class N extends q{static dataOnly=(z)=>new N(z);constructor(z,J=void 0,X){super("",J,X);new B(async()=>{super.value=await z()})}get value(){return super.value}set value(z){console.warn("you are not allowed to change Derived value manually")}}class v{constructor({workerPath:z,onMessage:J}){this.worker=new Worker(z),new F(!0,async()=>{this.worker.onmessage=(X)=>{J.success(X)},this.worker.onmessageerror=(X)=>{J.error(X)}})}worker;postMessage=(z,J)=>{this.worker.postMessage(z,J)}}var u=(z,J=!1)=>{return`vorth='${z}${J?";pre":""}'`};var g=async(z)=>{let{pathLibs:J,cacheDate:X,cacheDateName:Y}=H,Z=`${J}${z}.mjs`;try{let K=await import(`${Z}?${Y}=${X}`);if(!("lib"in K))throw Error("no_lib");return K.lib}catch(K){if(K.message==="no_data")console.error({endpoint:Z,error:K,message:"`importLib` point to a valid `endpoint`, but the `endpoint` have no named export as `lib`"});else console.error({endpoint:Z,404:"not found",message:"`importLib` pointing to invalid endpoint"});return}};var V=async(z,J=!0)=>{let{resume:X}=await T.unique(`importWorker-${z}`),{cachedWorker:Y,cacheDate:Z,pathWorkers:K,cacheDateName:G}=H;if(!J&&Y.has(z))return X(),Y.get(z);let W=`${K}/${z}.mjs?${G}=${Z}`,Q=new q({}),x=new v({onMessage:{error:(R)=>{new F(!0,async()=>{Q.value=R},{unique:x})},success:(R)=>{new F(!0,async()=>{Q.value=R},{unique:x})}},workerPath:W}),M={resultSignal:Q,postMessage:x.postMessage};if(J)Y.set(z,M);return X(),M};var b=async(z,J)=>{let{resume:X}=await T.unique(`importData-${z}`),{pathData:Y,cacheDate:Z,cacheDateName:K,cachedLet:G}=H,W=H.storageKey,Q=G.get(z);if(Q instanceof q)return X(),Q;let x=`${Y}${z}.mjs`;try{let M=await import(`${x}?${K}=${Z}`);if(!("data"in M))throw Error("no_data");let R=M.data;if(Array.isArray(R)){let $=W(z),[S,k]=R,j=S;try{if(k==="localStorage"){let w=localStorage.getItem($);if(w)j=JSON.parse(w)}else if(k==="sessionStorage"){let w=sessionStorage.getItem($);if(w)j=JSON.parse(w)}}catch(w){throw Error("cannot parse json")}let D=new q(j);if(k==="localStorage")new B(async()=>{localStorage.setItem($,JSON.stringify(D.value))});else if(k==="sessionStorage")new B(async()=>{sessionStorage.setItem($,JSON.stringify(D.value))});return G.set(z,D),X(),D}if(G.has(z))return G.get(z);let O=new N(async()=>{return await R({qFIFO:T.fifo,qUnique:T.unique,importData:async($)=>await b($,J),importLib:async($)=>{let S=await g($);return(...k)=>S.call(J,...k)},importWorker:async($)=>await V($,!0)})});return G.set(z,O),X(),O}catch(M){if(M.message==="cannot parse json")console.error({endpoint:x,error:M,message:"unable to parse json"});else if(M.message==="no_data")console.error({endpoint:x,error:M,data:"no_data",message:"`importData` point to a valid endpoint, but badly formed, default export must have `data` property"});else console.error({endpoint:x,error:M,404:"`importData` point to a invalid endpoint"});X();return}};var m=(z,J=[])=>{let X=new B(z);return J.push(X),X},p=(z,{isGlobal:J=!1,on:X,domReflect:Y=void 0,lifecycle:Z=void 0,waitForOnViewToRender:K=!0},G,W=!1)=>{return new I({attr:z,documentScope:J?document:G,onConnected:async({element:Q,onDisconnected:x,onViewPort:M,onAttributeChanged:R,lifecycleObserver:O})=>{let $=async()=>{let S=[],k=[];if(Y)H.derived({attr:z,data:Y},G,k,S);if(Z)await Z.call(Q,{$:(j)=>m(j,S),let_:(j)=>H.let(j,G,k,S),derived:(j)=>H.derived(j,G,k,S),onAttributeChanged:R,onDisconnected:x});x(async()=>{let j=Math.max(S.length,k.length);for(let D=0;D<j;D++){let w=k[D];if(w)w.unRef();let P=S[D];if(P)P.remove$()}if(W)O.disconnect()});for(let j in X){let{listener:D,options:w={}}=X[j],{onAdd:P=!1,onRemove:s=!1}=w;Q.addEventListener(j,D,P),x(async()=>{Q.removeEventListener(j,D,s)})}};if(!K){await $();return}M(async()=>{await $()})}}),{attr:z}};class d{constructor(z,J){this.element=z,new F(!0,async()=>{J(async()=>{this.eventRemover.forEach((Y)=>{Y(),this.eventRemover.delete(Y)});let X=this.effects;for(let Y=0;Y<X.length;Y++)X[Y].remove$()})})}element;effects=[];eventRemover=new Set;on=(z)=>{new F(!0,async()=>{let J=this.element;for(let X in z){let{listener:Y,options:Z={}}=z[X],{onAdd:K=!1,onRemove:G=!1}=Z;J.addEventListener(X,Y,K),this.eventRemover.add(()=>{J.removeEventListener(X,Y,G)})}})}}class H{static namespace="vorth";static domReflect="domReflect";static pre="pre";static versionMin=0;static properties_={batch:{value:E.loadCount},versionMin:{value:H.versionMin,onCompare:(z)=>{if(z<JSON.parse(H.cacheDate))return;setTimeout(()=>{H.cacheDate=JSON.stringify(Date.now()),location.reload()},1e4)}}};static assignProperties=()=>{let z=H.namespace;new I({attr:"property",documentScope:window.document,onConnected:async({element:J,onAttributeChanged:X})=>{let Y=async()=>{let Z=H.properties_;for(let K in Z){let G=`${z}-${K}`;if(!(J instanceof HTMLMetaElement)||!J.hasAttribute("property")||!J.hasAttribute("content")||J.getAttribute("property")!==G)continue;let W=J.getAttribute("content")??"";if(!W)continue;try{let Q=Z[K];if(Q.value=JSON.parse(W),Q.onCompare)Q.onCompare(W)}catch(Q){console.error({error:Q,value:W,propertyName:G,message:"somethings wrong while parsing and assigning vorth argument;",elementString:J.outerHTML})}}};X(Y),Y()}})};static cacheDateName=`${H.namespace}_now`;static cacheDate_;static set cacheDate(z){H.cacheDate_=z;let J=H.cacheDateName;sessionStorage.setItem(J,z)}static get cacheDate(){if(H.cacheDate_)return H.cacheDate_;let z=H.cacheDateName,J=sessionStorage.getItem(z);if(J)return H.cacheDate_=J,J;return J=JSON.stringify(Date.now()),H.cacheDate=J,J}static cachedWorker=new Map;static cachedLet=new Map;static importLifecycle=async(z)=>{let J=`${H.pathLifecycles}${z}.mjs`;try{let X=await import(`${J}?${H.cacheDateName}=${H.cacheDate}`);if(!("lifecycle"in X))throw Error("no_lifecycle");return X.lifecycle}catch(X){if(X.message==="no_lifecycle")console.error({endpoint:J,message:'vorth="endpoint" point to a valid `endpoint`, but the `endpoint` have no named export as `lifecycle`',error:X});else console.error({endpoint:J,404:"not found",message:'vorth="module-path" pointing to invalid endpoint',error:X});return!1}};static base="/";static storageKey=(z)=>`vorth-data-${z}`;static for=async({dataName:z,childLifescycle:J,element:X,waitForOnViewToRender:Y=!0,afterLoopCallback:Z=void 0,_:K=void 0})=>{let G=X.firstElementChild;if(G.cloneNode(!0),!(G instanceof HTMLElement))return;X.innerHTML="",G.setAttribute(H.namespace,Y?`${J};${H.pre}`:J);let W=await b(z,K);new B(async()=>{let Q=W.value,x=X.children,M=Math.max(x.length,Q.length);for(let R=0;R<M;R++){let O=Q[R],$=x[R];if(O){if($ instanceof HTMLElement&&H.looped.has($)){H.looped.get($).signal.value=O;continue}let S=G.cloneNode(!0);if(!(S instanceof HTMLElement))continue;H.looped.set(S,{name:z,index:R,signal:new q(O)}),X.append(S)}else if($)$.remove()}if(!Z)return;new F(!0,Z)})};static looped=new Map;static of=(z,J,X)=>{let Y=H.looped.get(J);return X.push(Y.signal),{get value(){return Y.signal.value},set value(Z){Y.signal.value=Z,Y.signal.call$()},get index(){return Y.index}}};static $=(z,J)=>{let X=new B(z);return J.push(X),X};static derived=(z,J,X,Y)=>{let Z;if("dataOnly"in z)Z=new N(z.dataOnly);else{let{attr:K,data:G}=z;Z=new N(G,K,{documentScope:J}),H.$(async()=>{q.domReflector(Z.value,K,J,Z)},Y)}return X.push(Z),Z};static let=(z,J,X,Y)=>{let Z;if("dataOnly"in z)Z=new q(z.dataOnly);else{let{attr:K,data:G}=z;Z=new q(G,K,{documentScope:J}),H.$(async()=>{q.domReflector(Z.value,K,J,Z)},Y)}return X.push(Z),Z};static lsCaller=async(z,J,X,Y,Z,K)=>{let G=[],W=[];await H.vorthLifecycle(z,J,X,Y,Z,K,W,G),Z(async()=>{let Q=Math.max(W.length,G.length);for(let x=0;x<Q;x++){let M=G[x];if(M)M.unRef();let R=W[x];if(R)R.remove$()}if(H.looped.has(J))H.looped.delete(J)})};static assignLifecycle=()=>{let z=H.namespace;new I({attr:z,documentScope:window.document,onConnected:async({element:J,html:X,onAttributeChanged:Y,onDisconnected:Z,onViewPort:K})=>{let[G,W=""]=(J.getAttribute(z)??"").replace(/\s/g,"").split(";");if(!G)return;let Q=async()=>{await H.lsCaller(G,J,X,Y,Z,K)};if(W===H.pre){await Q();return}K(async({removeOnExitCallback:x,removeOnViewCallback:M,unobserveElement:R})=>{M(),x(),R(),await Q()})}})};static triggerLifecycle=(z,J,X=!0)=>{let Y=J.cloneNode();if(!(Y instanceof HTMLElement))return;Y.setAttribute(H.namespace,X?z:`${z};${H.pre}`),J.outerHTML=Y.outerHTML};static vorthLifecycle=async(z,J,X,Y,Z,K,G,W)=>{let Q=await H.importLifecycle(z);if(!Q)return;let x={element:J,html:X,onAttributeChanged:Y,onDisconnected:Z,triggerLifecycle:H.triggerLifecycle,qFIFO:T.fifo,qUnique:T.unique,lifecycleAttr:u,importWorker:V,on:new d(J,Z).on,importData:async(M)=>await b(M,x),select:(M,R)=>p(M,R,J,!1),attr:({on:M,domReflect:R,lifecycle:O,waitForOnViewToRender:$=!0})=>p(U.attributeIndexGenerator(!0),{on:M,domReflect:R,lifecycle:O,isGlobal:!1,waitForOnViewToRender:$},J,!0).attr,importLib:async(M)=>{let R=await g(M);return async(...O)=>await R(x,...O)},$:(M)=>H.$(M,G),for_:{data:async(M)=>await H.for({element:J,...M,_:x}),of:(M=void 0)=>{return H.of(M,J,W)}},let_:(M)=>H.let(M,J,W,G),derived:(M)=>H.derived(M,J,W,G),onViewPort:K};await Q(x)};static pathData="";static pathLibs="";static pathLifecycles="";static pathWorkers="";static _;constructor(){if(H._ instanceof H){U.warningSingleton(H);return}H._=this,H.base=new URL("./",import.meta.url).href,H.pathData=`${H.base}data/`,H.pathLibs=`${H.base}libs/`,H.pathLifecycles=`${H.base}lifecycles/`,H.pathWorkers=`${H.base}workers/`,H.assignProperties(),H.assignLifecycle()}}new H;
