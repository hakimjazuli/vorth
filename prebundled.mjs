class Y{static webComponentGlobalStyles=[];static literal=(G,...J)=>{let Q=[];for(let X=0;X<G.length;X++)if(Q.push(G[X]),X<J.length)Q.push(J[X]);return Q.join("")};static subscriber=null;static debounce=0;static removeDOM$="virst-rm-dom$";static val="virst-a-val";static qRouteChange="virst-qrc";static getDocument=async(G)=>{if(G in Y.cachedDocument)return Y.cachedDocument[G];let J;try{if(J=await fetch(G),!J.ok)J=await fetch(`${G}.html`);if(!J.ok)throw Error(`Error fetching: status="${J.status}"`);let Q=await J.text(),X=new DOMParser;return Y.cachedDocument[G]=X.parseFromString(Q,"text/html")}catch(Q){console.error({error:Q,response:J})}};static cachedDocument={};static docScopeElement="virst-sc";static storageIdentifier="virst-st";static DCCBIdentifier="virst-dc";static ACCBIdentifier="virst-ac";static onViewCBIdentifier="virst-ov";static onExitViewCBIdentifier="virst-oxv";static templatePrefix="virst-template";static keptElement="virst-keep";static ForQPrefix="virst-fq-";static ForChildAttributePrefix="virst-fc-";static warningSingleton=(G)=>{console.warn({class:G,message:"is a singleton class, and can only be instantiated once"})};static generateUniqueString(){let G=Date.now(),J=Math.floor(Math.random()*1e6);return`${G}${J}`}static attr=null;static currentDocumentScope_=void 0;static get currentDocumentScope(){if(this.currentDocumentScope_===void 0)this.currentDocumentScope_=window.document;return this.currentDocumentScope_}static set currentDocumentScope(G){this.currentDocumentScope_=G}static attrPrefix="virst-ap-";static attributeIndexGenerator=(G=!1)=>{if(Y.currentDocumentScope==window.document&&!G)return this.attr=null;return this.attr=`${Y.attrPrefix}${this.generateUniqueString()}`};static timeout=(G)=>new Promise((J)=>setTimeout(J,G));static splitX=(G,J)=>{let Q=[],X="",Z=!1;for(let z=0;z<G.length;z++){let K=G[z];if(Z)X+=K,Z=!1;else if(K==="\\")Z=!0;else if(K===J)Q.push(X),X="";else X+=K}return Q.push(X),Q};static separator=";";static validAttributeNameSelector=(G)=>G.toLowerCase().replace(/:/g,"\\:");static handlePromiseAll=async(G,J,...Q)=>{if(!J)return;await Promise.all(J.map(async(X)=>{try{await X(...Q)}catch(Z){console.error({callback:X,source:G,message:"Error in callback",error:Z})}})).catch((X)=>{console.error({asyncArrayFunctions:J,source:G,message:"Promise.all failed:",error:X})})}}class j{constructor(){window.virst=window.virst??{},window.virst.QFIFO=window.virst.QFIFO??this.assign_}queue=[];isRunning=!1;assign_=(G)=>{if(this.push(G),!this.isRunning)this.run()};static _=new j;static assign=window.virst.QFIFO;push=(G)=>{this.queue.push(G.details)};run=async()=>{this.isRunning=!0;while(this.queue.length!==0){let[G,J]=this.queue[0];if(this.queue.shift(),J)await Y.timeout(J);await G()}this.isRunning=!1}}class w{details;constructor(G,J=0){this.details=[G,J]}}class D{constructor(){window.virst=window.virst||{},window.virst.QUnique=window.virst.QUnique||this.assign_}queue=new Map;isRunning=!1;assign_=(G)=>{if(this.push(G),!this.isRunning)this.run()};static _=new D;static assign=window.virst.QUnique;push=(G)=>{let{callback:J,debounce:Q,id:X}=G;this.queue.set(X,[J,Q?Q:0])};run=async()=>{this.isRunning=!0;let G=this.queue.keys(),J=G.next();while(!J.done){let Q=J.value,[X,Z]=this.queue.get(Q);this.queue.delete(Q),await Y.timeout(Z),await X(),J=G.next()}this.isRunning=!1}}class k{constructor(G,J,Q=0){this.id=G,this.callback=J,this.debounce=Q}id;callback;debounce}class _{asyncCallback;constructor(G,J,Q={fifo:!0}){if(this.asyncCallback=J,G){if("fifo"in Q)this.fifo(!0);if("unique"in Q)this.unique(Q.unique,!0)}}fifo=(G=!1)=>{j.assign(new w(async()=>{await this.asyncCallback(G)},Y.debounce))};unique=(G,J=!1)=>{D.assign(new k(G,async()=>{await this.asyncCallback(J)},Y.debounce))}}class ${effect;first=!0;constructor(G){this.effect=G,new _(!0,async()=>{Y.subscriber=G,await G(this.first),this.first=!1,Y.subscriber=null})}}class H{static __;static chachedTemplate={};constructor({callerAttribute:G,targetAttribute:J,targetPathRule:Q=(X)=>X}){if(H.__ instanceof H){Y.warningSingleton(H);return}H.__=this,H.targetAttribute=J,H.targetPathRule=Q,H.callerAttribute=G,new B({attributeName:G,bypassNested:!0,onConnected:async({element:X})=>{await this.renderElement({element:X})}})}static callerAttribute;static targetAttribute;static targetPathRule;swap=(G)=>{this.renderElement(G)};static replace=(G,J,Q="inner")=>{switch(Q){case"outer":let X=J[0].cloneNode(!0);G.replaceWith(X);break;case"inner":default:G.innerHTML=J[1];break}};renderElement=async({element:G,path:J,templateName:Q,mode:X="inner"})=>{if(!J||!Q){let W=H.callerAttribute,I=G.getAttribute(W);if(!I){console.warn({element:G,callerAttribute:W,message:`attributeName "${W}" must have value to be used as templateSelector`});return}[J,Q,X="inner"]=Y.splitX(I,Y.separator)}let Z=H.targetAttribute,z=H.targetPathRule(J),K=await H.fromCache(Z,z,Q);H.replace(G,K,X)};static fromCache=async(G,J,Q)=>{let X=H.chachedTemplate[J]?.[Q];if(X)return X;let Z=await Y.getDocument(J),z=Z.querySelectorAll("script");for(let E=0;E<z.length;E++)z[E].remove();H.chachedTemplate[J]={};let K=Z.body;H.chachedTemplate[J].body=[K,K.innerHTML];let W=Z.head;H.chachedTemplate[J].head=[W,W.innerHTML];let I=Z.querySelectorAll(`[${G}]`),U;for(let E=0;E<I.length;E++){let O=I[E],q=O.getAttribute(G);if(!(O instanceof HTMLElement))continue;if(H.chachedTemplate[J][q]=[O,O.innerHTML],q===Q)U=O}if(Q!=="head"&&Q!=="body"&&!U){console.error(`couldn't find '[${G}="${Q}"]' in the ${J}`);return}return H.chachedTemplate[J]?.[Q]}}class F{static domReflector=(G,J,Q,X)=>{let Z=Y.splitX(Q.getAttribute(J)??"",Y.separator);for(let z=0;z<Z.length;z++){let K=Z[z];try{if(!(K in Q))throw"";if(Q[K]=G,K==="value"&&"value"in Q&&Q.parentNode&&Q instanceof HTMLInputElement&&!Q.hasAttribute(Y.val))Q.setAttribute(Y.val,""),Q.oninput=()=>{X.value=Q.value}}catch(W){if(G=JSON.stringify(G).replace(/^"(.*)"$/,"$1"),K==""){console.warn({element:Q,attributeName:J,message:"doesn't have target"});return}Q.setAttribute(K,G)}}};static dataOnly=(G)=>new F(G);removeAll$=()=>{this.subscription=[]};remove$=(G)=>{this.subscription=this.subscription.filter((J)=>G.effect!==J)};unRef=()=>{this.removeAll$(),this.value_=null,this.attr=null};subscription=[];value_;call$=()=>{new _(!0,async()=>{await Y.handlePromiseAll(this,this.subscription,!1)})};constructor(G,J=void 0,Q={}){if(this.value_=G,J){this.attr=J;let{bypassNested:X=!0,documentScope:Z=void 0}=Q;new B({documentScope:Z,attributeName:J,bypassNested:X,onConnected:async({element:z,onDisconnected:K})=>{let W=new $(async()=>{F.domReflector(this.value,J,z,this)});z[Y.removeDOM$]=async()=>{if(this.remove$(W),typeof z.oninput==="function")z.oninput=null},K(z[Y.removeDOM$])}})}}attr=void 0;get value(){if(Y.subscriber&&!this.subscription.some((G)=>G===Y.subscriber))this.subscription.push(Y.subscriber);return this.value_}set value(G){if(this.value_===G)return;this.value_=G,this.call$()}}class x{constructor({element:G,onExitViewCallback:J,onViewCallback:Q,lifecyclesOnDisconnected:X}){this.element=G,x.observer.observe(G),G[Y.onViewCBIdentifier]=Q,G[Y.onExitViewCBIdentifier]=J;for(let Z=0;Z<X.length;Z++)X[Z](async()=>{if(x.removeOnViewCallback(G),G[Y.onExitViewCBIdentifier])await G[Y.onExitViewCBIdentifier](x.onViewCallbacksOptions(G));x.removeOnExitViewCallback(G),x.unobserve(G)})}element;disconnect=async()=>{let G=this.element;if(x.removeOnViewCallback(G),G[Y.onExitViewCBIdentifier])await G[Y.onExitViewCBIdentifier](x.onViewCallbacksOptions(G));x.removeOnExitViewCallback(G),x.unobserve(G)};static observer=new IntersectionObserver((G)=>{new _(!0,async()=>{for(let J=0;J<G.length;J++)await this.handleEntry(G[J])})},{threshold:[0,0]});static takeRecords=()=>this.observer.takeRecords();static disconnect=()=>this.observer.disconnect();static get root(){return this.observer.root}static get rootMargin(){return this.observer.rootMargin}static unobserve=(G)=>this.observer.unobserve(G);static removeOnViewCallback=(G)=>{if(Y.onViewCBIdentifier in G)delete G[Y.onViewCBIdentifier]};static removeOnExitViewCallback=(G)=>{if(Y.onExitViewCBIdentifier in G)delete G[Y.onExitViewCBIdentifier]};static onViewCallbacksOptions=(G)=>{return{removeOnViewCallback:()=>x.removeOnViewCallback(G),removeOnExitViewCallback:()=>x.removeOnExitViewCallback(G),unobserveElement:()=>x.unobserve(G)}};handlers=(G)=>{return x.onViewCallbacksOptions(G)};static registeredOnExit=new Map;static handleEntry=async(G)=>{let J=G.target;if(G.isIntersecting&&Y.onViewCBIdentifier in J)await J[Y.onViewCBIdentifier](x.onViewCallbacksOptions(J)),this.registeredOnExit.set(J,!0);if(!G.isIntersecting&&Y.onExitViewCBIdentifier in J&&this.registeredOnExit.has(J))await J[Y.onExitViewCBIdentifier](x.onViewCallbacksOptions(J)),this.registeredOnExit.delete(J)}}class B{attr;static registeredDocumentScope=[];static createMutationObserver=(G)=>{let J=B.registeredDocumentScope.filter((z)=>{return z[2]===G})[0];if(J)return J;let Q=F.dataOnly(""),X=new MutationObserver((z)=>{Q.value=z});X.observe(G,{childList:!0,subtree:!0,attributes:!0});let Z=[X,Q,G];return B.registeredDocumentScope.push(Z),Z};static shallowScope=async({documentScope:G,scopedCallback:J})=>{let Q=Y.currentDocumentScope;Y.currentDocumentScope=G,await J(),Y.currentDocumentScope=Q};static scopedPing=({documentScope:G,scopedCallback:J,runCheckAtFirst:Q})=>new _(Q,async()=>{let X=Y.currentDocumentScope;Y.currentDocumentScope=G,await J(),Y.currentDocumentScope=X}).fifo;static onParentDCWrapper=async(G,J)=>{let Q=(Z)=>{B.setDCCB(G,Z)},X=B.currentOnParentDCCB;B.currentOnParentDCCB=Q,await J(),B.currentOnParentDCCB=X};static currentOnParentDCCB=void 0;static ID=new Map;currentDocumentScope;disconnect=()=>{if(this.effect)this.mutationSignal.remove$(this.effect);let G=this.currentDocumentScope;if(G!==document)this.mutationObserver.disconnect(),B.ID.delete(G)};takeRecords;mutationSignal;mutationObserver;effect;onConnected;assignBypass=()=>{let G=this.attr,J=this.currentDocumentScope,Q=B.bypassNest.get(J);if(!Q)B.bypassNest.set(J,[G]);else Q.push(G)};static bypassNest=new Map;constructor({onConnected:G,attributeName:J=Y.attributeIndexGenerator(),documentScope:Q=Y.currentDocumentScope,bypassNested:X=!1}){if(this.attr=J,this.onConnected=G,this.currentDocumentScope=Q,X)this.assignBypass();let[Z,z]=B.createMutationObserver(Q);this.mutationObserver=Z,this.mutationSignal=z,this.takeRecords=Z.takeRecords;let K=this.isScopeMapped(),W=B.currentOnParentDCCB;if(W)W(async()=>{this.disconnect()});switch(K){case"newScope":this.effect=new $(async(I)=>{let U=z.value;if(I){await this.initiator();return}await this.mutationHandler(U)});break;case"addToScope":B.scopedPing({documentScope:Q,runCheckAtFirst:!0,scopedCallback:async()=>{await this.initiator()}});break;default:console.error({documentScope:Q,message:`'${K}' already registered in this 'documentScope'`,registeredAttributes:Object.keys(B.ID.get(Q))});break}}isScopeMapped=()=>{let G=this.currentDocumentScope;if(!B.ID.has(G))return B.ID.set(G,{[this.attr]:this.onConnected}),"newScope";if(this.attr in B.ID.get(G))return this.attr;return B.ID.get(G)[this.attr]=this.onConnected,"addToScope"};initiator=async()=>{await this.checkNestedAddedNodes(this.currentDocumentScope,this.attr)};checkValidScoping=(G,J)=>{let Q=G;if(!(G instanceof HTMLElement))return!1;let X=this.currentDocumentScope,Z=!1,z=B.bypassNest.get(X);if(z){if(z.includes(J))return G.setAttribute(Y.docScopeElement,""),!0}while(G){if("hasAttribute"in G&&!G.hasAttribute(Y.docScopeElement)){if(!Z&&Q===G)Z=!0,Q.setAttribute(Y.docScopeElement,"");G=G.parentElement;continue}if(G===X)return!0;return!1}return!0};static addedNodeScoper=(G,J)=>{B.scopedPing({documentScope:G,runCheckAtFirst:!0,scopedCallback:async()=>{B.onParentDCWrapper(G,J)}})};static registeredLCCB=new Map;addedNodeHandler=async(G,J)=>{if(!(G instanceof HTMLElement))return;if(!("hasAttribute"in G)||!G.hasAttribute(J)||!this.checkValidScoping(G,J))return;if(B.registeredLCCB.has(G))return;B.registeredLCCB.set(G,!0);let Q=B.ID.get(this.currentDocumentScope)[J];B.addedNodeScoper(G,async()=>{if(G.parentElement)Q({get isConnected(){return G.isConnected},swap:(X)=>{if(!(H instanceof H))return;H.__.swap({element:G,...X})},onViewPort:(X)=>new x({element:G,...X}),element:G,html:(X,...Z)=>{G.innerHTML=Y.literal(X,...Z)},lifecycleObserver:this,onDisconnected:(X)=>{B.setDCCB(G,async()=>{B.addedNodeScoper(G,async()=>{await X(),B.registeredLCCB.delete(G)})})},onAttributeChanged:(X)=>{B.setACCB(G,async(Z)=>{B.addedNodeScoper(G,async()=>{await X(Z)})})}})})};static setDCCB=(G,J)=>{if(!(Y.DCCBIdentifier in G))G[Y.DCCBIdentifier]=[];G[Y.DCCBIdentifier].push(J)};static getDCCB=(G)=>{if(!(Y.DCCBIdentifier in G))return;return G[Y.DCCBIdentifier]};static setACCB=(G,J)=>{G[Y.ACCBIdentifier]=J};static getACCB=(G)=>{if(!(Y.ACCBIdentifier in G))return;return G[Y.ACCBIdentifier]};callACCB=async(G,J)=>{let Q=B.getACCB(G);if(!Q)return;await Q({attributeName:J,newValue:G.getAttribute(J)??""})};checkNestedAddedNodes=async(G,J)=>{let Q=Y.validAttributeNameSelector(J);if("querySelectorAll"in G){let X=G.querySelectorAll(`[${Q}]`);for(let Z=0;Z<X.length;Z++)await this.addedNodeHandler(X[Z],J)}};mutationHandler=async(G)=>{let J=B.ID.get(this.currentDocumentScope);for(let Q=0;Q<G.length;Q++){let X=G[Q];if(X.addedNodes)for(let z=0;z<X.addedNodes.length;z++){let K=X.addedNodes[z];for(let W in J)await this.addedNodeHandler(K,W),await this.checkNestedAddedNodes(K,W)}if(X.removedNodes)for(let z=0;z<X.removedNodes.length;z++){let K=X.removedNodes[z];if(!(K instanceof HTMLElement))continue;await this.mutationDCHandler(K)}if(X.type!=="attributes")continue;let Z=X.target;if(Z instanceof HTMLElement&&X.attributeName)this.callACCB(Z,X.attributeName)}};removeParentOfNestedLCDCCB=(G)=>{if(B.ID.has(G))G[Y.DCCBIdentifier].push(async()=>{B.ID.delete(G)})};mutationDCHandler=async(G)=>{let J=B.findDeepNested(G),Q=[];for(let X=0;X<J.length;X++){let Z=J[X];if(!(Z instanceof HTMLElement))continue;this.removeParentOfNestedLCDCCB(Z);let z=B.getDCCB(Z);if(z)Q.push(...z)}await Y.handlePromiseAll(this,Q)};static findDeepNested=(G,J=[])=>{if(B.getDCCB(G))J.push(G);for(let Q=0;Q<G.children.length;Q++)B.findDeepNested(G.children[Q],J);return J}}class A extends F{static dataOnly=(G)=>new A(G);constructor(G,J=void 0,Q){super("",J,Q);new $(async()=>{super.value=await G()})}get value(){return super.value}set value(G){console.warn("you are not allowed to change Derived value manually")}}class T{static __;constructor(){if(T.__ instanceof T)return;T.__=this,this.setDate(),this.setBase(),this.vorthLifecycle()}setDate=()=>{let J=sessionStorage.getItem("vorth-now");if(J){this.cacheDate=J;return}J=`?t=${Date.now()}`,sessionStorage.setItem("vorth-now",J),this.cacheDate=J;return};cacheDate;chacedRef=new Map;cachedLet=new Map;cachedLib=new Map;setBase=()=>{this.base=new URL("./",import.meta.url).href};importVorth=async(G)=>{let J=this.chacedRef.get(G);if(J)return J;let Q=`${this.base}lifecycles/${G}.mjs`;try{let X=(await import(`${Q}${this.cacheDate}`)).default;return this.chacedRef.set(G,X),X}catch(X){return console.error({endpoint:Q,code:404,error:"not found",message:'vorth="module-path" pointing to invalid endpoint'}),!1}};base="/";storageKey=(G)=>`vorth-s-${G}`;importLib=async(G)=>{let J=this.cachedLib.get(G);if(J)return J;let Q=`${this.base}libs/${G}.mjs`;try{let X=(await import(`${Q}${this.cacheDate}`)).default;return this.cachedLib.set(G,X),X}catch(X){return console.error({endpoint:Q,code:404,error:"not found",message:"importLib pointing to invalid endpoint"}),!1}};importData=async(G)=>{let J=this.cachedLet.get(G);if(J)return J.signal;let Q=`${this.base}data/${G}.mjs`;try{let X=(await import(`${Q}${this.cacheDate}`)).default;if(!("data"in X))throw Error("no_data");if("storeMode"in X){let Z=this.storageKey(G),{data:z,storeMode:K}=X,W=z.let;if(K==="localStorage"){let U=localStorage.getItem(Z);if(U)W=JSON.parse(U)}else if(K==="sessionStorage"){let U=sessionStorage.getItem(Z);if(U)W=JSON.parse(U)}let I=new F(W);if(this.cachedLet.set(G,{data:z,storeMode:K,signal:I}),K==="localStorage")new $(async()=>{localStorage.setItem(Z,JSON.stringify(I.value))});else if(K==="sessionStorage")new $(async()=>{sessionStorage.setItem(Z,JSON.stringify(I.value))});return I}else{let{data:Z}=X,z=new A(async()=>{return await Z.derived({importData:this.importData,importLib:this.importLib})});return this.cachedLet.set(G,{data:Z,signal:z}),z}}catch(X){if(X==="no_data")console.error({endpoint:Q,error:"no data",message:"signalRef point to a valid endpoint, but badly formed, default export must have `data` property"});else console.error({endpoint:Q,code:404,error:"not found",message:"signalRef pointing to invalid endpoint"});return!1}};loopedAttr="vorth-loop";for=({element:G,signal:J,childLifescyclePath:Q,afterLoopCallback:X})=>{let Z=G.firstElementChild.cloneNode(!0);if(!(Z instanceof HTMLElement))return;G.innerHTML="";let z=this.loopedAttr;Z.setAttribute(z,"{}"),Z.setAttribute("vorth",Q),new $(async()=>{let K=J.value,W=G.childNodes,I=0;for(let U=0;U<K.length;U++){I++;let E=K[U],O=W[U];if(O&&O instanceof HTMLElement){O.setAttribute(z,JSON.stringify(E));continue}let q=Z.cloneNode(!0);if(!(q instanceof HTMLElement))break;q.setAttribute(z,JSON.stringify(E)),G.append(q)}for(let U=I;U<W.length;U++)W[U].remove();if(!X)return;new _(!0,X)})};vorthLifecycle=()=>{new B({attributeName:"vorth",bypassNested:!0,documentScope:document,onConnected:async({element:J,html:Q,isConnected:X,onAttributeChanged:Z,onDisconnected:z,onViewPort:K})=>{let W=J.getAttribute("vorth");if(!W)return;K({lifecyclesOnDisconnected:[z],onExitViewCallback:async()=>{},onViewCallback:async({unobserveElement:I,removeOnExitViewCallback:U,removeOnViewCallback:E})=>{E(),U(),I();let O=await this.importVorth(W);if(!O)return;let q=[];await O({element:J,html:Q,isConnected:X,onAttributeChanged:Z,onDisconnected:z,onViewPort:K,importLib:this.importLib,$:(R)=>new $(R),loopedAttrName:this.loopedAttr,parsedLoopedAttr:()=>{try{let R=J.getAttribute(this.loopedAttr);return JSON.parse(R)}catch(R){return R}},for_:(R)=>this.for({element:J,...R}),importData:this.importData,let_:(R)=>{let M=!1;if("dataOnly"in R)M=new F(R.dataOnly);else{let{attributeName:S,data:V}=R;M=new F(V,S,{bypassNested:!1,documentScope:J}),new $(async()=>{try{F.domReflector(M.value,S,J,M)}catch(v){console.log(v)}})}return q.push(M),M},derived:(R)=>{let M=!1;if("dataOnly"in R)M=new A(R.dataOnly);else{let{attributeName:S,data:V}=R;M=new A(V,S,{bypassNested:!1,documentScope:J}),new $(async()=>{try{F.domReflector(M.value,S,J,M)}catch(v){console.log(v)}})}return q.push(M),M}}),z(async()=>{for(let R=0;R<q.length;R++){let M=q[R];if(M)M.unRef()}})}})}})}}new T;
