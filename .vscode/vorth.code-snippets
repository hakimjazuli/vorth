{
	/**
	 * vorth official snippets
	 */
	"workerThread": {
		"scope": "javascript",
		"prefix": ">>workerThread",
		"body": [
			"// @ts-check",
			"",
			"/**",
			" * @type {(this: WindowEventHandlers, ev: MessageEvent) =>Promise<any>}",
			" */",
			"self.onmessage = async function (event) {",
			"// code....",
			"// self.postMessage(${0:message})",
			"};"
		],
		"description": "workerThread"
	},
	"tsworkerThread": {
		"scope": "typescript",
		"prefix": ">>workerThread",
		"body": [
			"const worker: (this: WindowEventHandlers, ev: MessageEvent) => Promise<any> = async function (",
			"event",
			") {",
			"// code....",
			"// self.postMessage(message)",
			"};",
			"self.onmessage = worker;"
		],
		"description": "tsworkerThread"
	},
	"VorthData": {
		"scope": "javascript",
		"prefix": ">>data",
		"body": [
			"// @ts-check",
			"",
			"/**",
			"* @type {import('vorth')..vorthData<${1:isDerived?}, ${2:signalValueType}>}",
			"*/",
			"export const data = ${0:}"
		],
		"description": "VorthData"
	},
	"tsVorthData": {
		"scope": "typescript",
		"prefix": ">>data",
		"body": [
			"import type { vorthData } from 'vorth';",
			"",
			"export const data: vorthData<${1:isDerived?}, ${2:signalValueType}> =${0:}"
		],
		"description": "tsVorthData"
	},
	"StaticVorthData": {
		"scope": "javascript",
		"prefix": ">>staticData",
		"body": [
			"// @ts-check",
			"/**",
			" * @typedef {{}|null|number|string|boolean|symbol|bigint|function} anyButUndefined",
			" * @typedef {Object} \\$Instance",
			" * @property {()=>void} remove$",
			" * @property {(isAtInitialization:boolean)=>Promise<void>} effect",
			" * @typedef {Object} letInstance",
			" * @property {any} value",
			" * @property {string|null} attr",
			" * @property {()=>void} call$",
			" * @property {(effect:\\$Instance)=>void} remove$",
			" * @property {()=>void} removeAll$",
			" * @property {()=>void} unRef",
			" * @callback derivedFunction",
			" * @param {Object} options",
			" * @param {(dataPath:string)=>Promise<void|letInstance>} options.importData",
			" * @param {(libPath:string)=>Promise<void|((...any:any)=>Promise<any>)>} options.importLib",
			" * @param {(workerPath:string)=>Promise<{resultSignal:letInstance, postMessage:(message: any, options?: StructuredSerializeOptions)=>void}>} options.importWorker",
			" * @param {()=>Promise<{resume:()=>void}>} options.qFIFO",
			" * @param {(id:anyButUndefined)=>Promise<{resume:()=>void}>} options.qUnique",
			" * @returns {Promise<anyButUndefined>}",
			" * @typedef {derivedFunction|[signalValueType:anyButUndefined, storeMode?:'sessionStorage'|'localStorage'|undefined]} vorthData",
			" * @type {vorthData}",
			" */",
			"export const data = ${1://code};"
		],
		"description": "StaticVorthData"
	},
	"VorthLib": {
		"scope": "javascript",
		"prefix": ">>lib",
		"body": [
			"// @ts-check",
			"/**",
			"* @type {import('vorth')..vorthLib<(${1:...argumentsTypes})=>Promise<${3:returnType}>>}",
			"*/",
			"export const lib = async (",
			"{${4:...vorthOptions}},",
			"${2:parameters}",
			") => {",
			"\t${0://code}",
			"};"
		],
		"description": "VorthLib"
	},
	"tsVorthLib": {
		"scope": "typescript",
		"prefix": ">>lib",
		"body": [
			"import type { vorthLib } from 'vorth';",
			"",
			"export const lib: vorthLib<(${1:...argumentsTypes})=>Promise<${3:returnType}>> = async (",
			"{${4:...vorthOptions}},",
			"${2:parameters}",
			") => {",
			"\t${0://code}",
			"};"
		],
		"description": "tsVorthLib"
	},
	"StaticVorthLib": {
		"scope": "javascript",
		"prefix": ">>staticLib",
		"body": [
			"// @ts-check",
			"/**",
			" * @typedef {{}|null|number|string|boolean|symbol|bigint|function} anyButUndefined",
			" * @typedef {Object} \\$Instance",
			" * @property {()=>void} remove$",
			" * @property {(isAtInitialization:boolean)=>Promise<void>} effect",
			" * @callback \\$__",
			" * @param {(isAtInitialization:boolean)=>Promise<void>} effect",
			" * @returns {\\$Instance}",
			" * @typedef {Object} letInstance",
			" * @property {anyButUndefined} value",
			" * @property {string|null} attr",
			" * @property {()=>void} call$",
			" * @property {(effect:\\$Instance)=>void} remove$",
			" * @property {()=>void} removeAll$",
			" * @property {()=>void} unRef",
			" * @callback VorthLet",
			" * @param {{dataOnly:anyButUndefined}|{attr:string, data:anyButUndefined}} obj",
			" * @returns {letInstance}",
			" * @typedef {letInstance} derivedInstance",
			" * @callback VorthDerived",
			" * @param {{dataOnly:()=>Promise<anyButUndefined>}|{attr:string, data:()=>Promise<anyButUndefined>}} obj",
			" * @returns {derivedInstance}",
			" * @typedef {{[K in keyof HTMLElementEventMap]? :{listener:(this: HTMLElement, ev: HTMLElementEventMap[K])=> void, options?:{onAdd?:boolean|AddEventListenerOptions, onRemove?:boolean|EventListenerOptions}}}} selectArg_On",
			" * @callback ForData",
			" * @param {Object} a0",
			" * @param {string} a0.dataName",
			" * @param {string} a0.childLifescycle",
			" * @param {HTMLElement} [a0.element]",
			" * @param {boolean} [a0.waitForOnViewToRender]",
			" * @param {()=>Promise<void>} [a0.afterLoopCallback]",
			" * @returns {Promise<void>}",
			" * @typedef {(handler:()=>Promise<void>)=>void} vorthOnDisconnected",
			" * @typedef {Object} onViewCallbackOptions",
			" * @property {(arg0:()=>Promise<void>)=>void} onExitViewPort",
			" * @property {()=>void} unobserveElement",
			" * @property {()=>void} removeOnViewCallback",
			" * @property {()=>void} removeOnExitCallback",
			" * @callback VorthSelect",
			" * @param {string} attributeName",
			" * @param {Object} a0",
			" * @param {(this: HTMLElement, options:{$:\\$__, let_:VorthLet, derived:VorthDerived, onAttributeChanged:(arg0:import('virst').attributeChangedLifecycle)=>void, onDisconnected:(arg0:()=>Promise<void>)=>void})=>Promise<void>} [a0.lifecycle]",
			" * @param {()=>Promise<anyButUndefined>} [a0.domReflect]",
			" * @param {selectArg_On} a0.on",
			" * @param {boolean} [a0.waitForOnViewToRender]",
			" * @param {boolean} [a0.isGlobal]",
			" * @returns {{attr:string}}",
			" * @typedef {Object} vorthLifecycleOptions",
			" * @property {(effect:\\$Instance[\"effect\"])=>\\$Instance} $",
			" * @property {(options:{domReflect?:()=>Promise<anyButUndefined>, lifecycle?:(this: HTMLElement, options:{$:\\$__, let_:VorthLet, derived:VorthDerived, onAttributeChanged:(handler:(options:{attr:string, newValue:string})=>Promise<void>)=>void, onDisconnected:(arg0:()=>Promise<void>)=>void})=>Promise<void>, on?:selectArg_On, waitForOnViewToRender?:boolean})=>string} attr",
			" * @property {VorthDerived} derived",
			" * @property {HTMLElement} element",
			" * @property {{data:ForData, of:()=>{index:number, value:{[key:string]:string}|undefined}|false}} for_",
			" * @property {(strings:TemplateStringsArray,...values:string[])=>{inner:()=>void, string:string}} html",
			" * @property {(dataName:string)=>Promise<letInstance>} importData",
			" * @property {(libName:string)=>Promise<(...any:any)=>Promise<any>>} importLib",
			" * @property {(workerName:string, sharedSignal?:boolean)=>Promise<{resultSignal:{value:MessageEvent}, postMessage:(message: any, options?: StructuredSerializeOptions)=>void}>} importWorker",
			" * @property {VorthLet} let_",
			" * @property {(lifecycleName:string)=>string} lifecycleAttr",
			" * @property {(events:{[K in keyof HTMLElementEventMap]?: {listener:((this: HTMLElement, ev: HTMLElementEventMap[K])=> void), options?:{onAdd?:boolean|AddEventListenerOptions, onRemove?:boolean|EventListenerOptions}}})=>void} on",
			" * @property {(handler:(options:{attr:string, newValue:string})=>Promise<void>)=>void} onAttributeChanged",
			" * @property {vorthOnDisconnected} onDisconnected",
			" * @property {(onViewCallback: (onSightCallbackOptions:onViewCallbackOptions)=>Promise<void>) => void} onViewPort",
			" * @property {()=>{resume:(()=>void)}} qFIFO",
			" * @property {(id:any)=>{resume:(()=>void)}} qUnique",
			" * @property {VorthSelect} select",
			" * @property {(lifecycleName:string, element:HTMLElement, waitForOnViewToRender?:boolean)=>void} triggerLifecycle",
			" * @typedef {(vorthLifecycleOptions:vorthLifecycleOptions, ...any:any)=>Promise<any>} StaticVorthLib",
			" * @type {StaticVorthLib}",
			" */",
			"export const lib = async ({${1:...vorthLifecycleOptions}}, ${2:...args}) => {",
			"${0:// code;}",
			"};"
		],
		"description": "StaticVorthLib"
	},
	"tsVorthLifecycle": {
		"scope": "typescript",
		"prefix": ">>lifecycle",
		"body": [
			"import type { vorthLifecycle } from 'vorth';",
			"",
			"export const lifecycle: vorthLifecycle = async ({${1:...vorthLifecycleOptions}}) => {",
			"\t${0:// code}",
			"};"
		],
		"description": "tsVorthLifecycle"
	},
	"VorthLifecycle": {
		"scope": "javascript",
		"prefix": ">>lifecycle",
		"body": [
			"// @ts-check",
			"/**",
			"* @type {import('vorth').vorthLifecycle = async ({${1:...vorthLifecycleOptions}})}",
			"*/",
			"export const lifecycle => {",
			"\t${0:// code}",
			"};"
		],
		"description": "VorthLifecycle"
	},
	"StaticVorthLifecycle": {
		"scope": "javascript",
		"prefix": ">>staticLifecycle",
		"body": [
			"// @ts-check",
			"/**",
			" * @typedef {{}|null|number|string|boolean|symbol|bigint|function} anyButUndefined",
			" * @typedef {Object} \\$Instance",
			" * @property {()=>void} remove$",
			" * @property {(isAtInitialization:boolean)=>Promise<void>} effect",
			" * @callback \\$__",
			" * @param {(isAtInitialization:boolean)=>Promise<void>} effect",
			" * @returns {\\$Instance}",
			" * @typedef {Object} letInstance",
			" * @property {anyButUndefined} value",
			" * @property {string|null} attr",
			" * @property {()=>void} call$",
			" * @property {(effect:\\$Instance)=>void} remove$",
			" * @property {()=>void} removeAll$",
			" * @property {()=>void} unRef",
			" * @callback VorthLet",
			" * @param {{dataOnly:anyButUndefined}|{attr:string, data:anyButUndefined}} obj",
			" * @returns {letInstance}",
			" * @typedef {letInstance} derivedInstance",
			" * @callback VorthDerived",
			" * @param {{dataOnly:()=>Promise<anyButUndefined>}|{attr:string, data:()=>Promise<anyButUndefined>}} obj",
			" * @returns {derivedInstance}",
			" * @typedef {{[K in keyof HTMLElementEventMap]? :{listener:(this: HTMLElement, ev: HTMLElementEventMap[K])=> void, options?:{onAdd?:boolean|AddEventListenerOptions, onRemove?:boolean|EventListenerOptions}}}} selectArg_On",
			" * @callback ForData",
			" * @param {Object} a0",
			" * @param {string} a0.dataName",
			" * @param {string} a0.childLifescycle",
			" * @param {HTMLElement} [a0.element]",
			" * @param {boolean} [a0.waitForOnViewToRender]",
			" * @param {()=>Promise<void>} [a0.afterLoopCallback]",
			" * @returns {Promise<void>}",
			" * @typedef {(handler:()=>Promise<void>)=>void} vorthOnDisconnected",
			" * @typedef {Object} onViewCallbackOptions",
			" * @property {(arg0:()=>Promise<void>)=>void} onExitViewPort",
			" * @property {()=>void} unobserveElement",
			" * @property {()=>void} removeOnViewCallback",
			" * @property {()=>void} removeOnExitCallback",
			" * @callback VorthSelect",
			" * @param {string} attributeName",
			" * @param {Object} a0",
			" * @param {(this: HTMLElement, options:{$:\\$__, let_:VorthLet, derived:VorthDerived, onAttributeChanged:(arg0:import('virst').attributeChangedLifecycle)=>void, onDisconnected:(arg0:()=>Promise<void>)=>void})=>Promise<void>} [a0.lifecycle]",
			" * @param {()=>Promise<anyButUndefined>} [a0.domReflect]",
			" * @param {selectArg_On} a0.on",
			" * @param {boolean} [a0.waitForOnViewToRender]",
			" * @param {boolean} [a0.isGlobal]",
			" * @returns {{attr:string}}",
			" * @typedef {Object} vorthLifecycleOptions",
			" * @property {(effect:\\$Instance[\"effect\"])=>\\$Instance} $",
			" * @property {(options:{domReflect?:()=>Promise<anyButUndefined>, lifecycle?:(this: HTMLElement, options:{$:\\$__, let_:VorthLet, derived:VorthDerived, onAttributeChanged:(handler:(options:{attr:string, newValue:string})=>Promise<void>)=>void, onDisconnected:(arg0:()=>Promise<void>)=>void})=>Promise<void>, on?:selectArg_On, waitForOnViewToRender?:boolean})=>string} attr",
			" * @property {VorthDerived} derived",
			" * @property {HTMLElement} element",
			" * @property {{data:ForData, of:()=>{index:number, value:{[key:string]:string}|undefined}|false}} for_",
			" * @property {(strings:TemplateStringsArray,...values:string[])=>{inner:()=>void, string:string}} html",
			" * @property {(dataName:string)=>Promise<letInstance>} importData",
			" * @property {(libName:string)=>Promise<(...any:any)=>Promise<any>>} importLib",
			" * @property {(workerName:string, sharedSignal?:boolean)=>Promise<{resultSignal:{value:MessageEvent}, postMessage:(message: any, options?: StructuredSerializeOptions)=>void}>} importWorker",
			" * @property {VorthLet} let_",
			" * @property {(lifecycleName:string)=>string} lifecycleAttr",
			" * @property {(events:{[K in keyof HTMLElementEventMap]?: {listener:((this: HTMLElement, ev: HTMLElementEventMap[K])=> void), options?:{onAdd?:boolean|AddEventListenerOptions, onRemove?:boolean|EventListenerOptions}}})=>void} on",
			" * @property {(handler:(options:{attr:string, newValue:string})=>Promise<void>)=>void} onAttributeChanged",
			" * @property {vorthOnDisconnected} onDisconnected",
			" * @property {(onViewCallback: (onSightCallbackOptions:onViewCallbackOptions)=>Promise<void>) => void} onViewPort",
			" * @property {()=>{resume:(()=>void)}} qFIFO",
			" * @property {(id:any)=>{resume:(()=>void)}} qUnique",
			" * @property {VorthSelect} select",
			" * @property {(lifecycleName:string, element:HTMLElement, waitForOnViewToRender?:boolean)=>void} triggerLifecycle",
			" * @typedef {(options:vorthLifecycleOptions)=>Promise<void>} StaticVorthLifecycle",
			" * @type {StaticVorthLifecycle}",
			" */",
			"export const lifecycle = async({ ${1:...vorthLifecycleOptions} })=>{",
			"${0:// code;}",
			"};"
		],
		"description": "StaticVorthLifecycle"
	}
}
