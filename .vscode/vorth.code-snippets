{
	/**
	 * vorth official snippets
	 */
	"workerThread": {
		"scope": "javascript",
		"prefix": ">>workerThread",
		"body": [
			"// @ts-check",
			"",
			"/**",
			" * @type {(this: WindowEventHandlers, ev: MessageEvent) =>Promise<any>}",
			" */",
			"self.onmessage = async function (event) {",
			"// code....",
			"// self.postMessage(${0:message})",
			"};"
		],
		"description": "workerThread"
	},
	"tsworkerThread": {
		"scope": "typescript",
		"prefix": ">>workerThread",
		"body": [
			"const worker: (this: WindowEventHandlers, ev: MessageEvent) => Promise<any> = async function (",
			"event",
			") {",
			"// code....",
			"// self.postMessage(message)",
			"};",
			"self.onmessage = worker;"
		],
		"description": "tsworkerThread"
	},
	"VorthData": {
		"scope": "javascript",
		"prefix": ">>data",
		"body": [
			"// @ts-check",
			"",
			"/**",
			"* @type {import('vorth')..vorthData<${1:isDerived?}, ${2:signalValueType}>}",
			"*/",
			"export const data = ${0:}"
		],
		"description": "VorthData"
	},
	"tsVorthData": {
		"scope": "typescript",
		"prefix": ">>data",
		"body": [
			"import type { vorthData } from 'vorth';",
			"",
			"export const data: vorthData<${1:isDerived?}, ${2:signalValueType}> =${0:}"
		],
		"description": "tsVorthData"
	},
	"StaticVorthData": {
		"scope": "javascript",
		"prefix": ">>staticData",
		"body": [
			"// @ts-check",
			"/**",
			"* @typedef {{}|null|number|string|boolean|symbol|bigint|function} anyButNull",
			"* @typedef {Object} \\$Instance",
			"* @property {()=>void} remove$",
			"* @property {(isAtInitialization:boolean)=>Promise<void>} effect",
			"* @typedef {Object} letInstance",
			"* @property {any} value",
			"* @property {string|null} attr",
			"* @property {()=>void} call$",
			"* @property {(effect:\\$Instance)=>void} remove$",
			"* @property {()=>void} removeAll$",
			"* @property {()=>void} unRef",
			"* @callback derivedFunction",
			"* @param {Object} options",
			"* @param {(relativePath:string)=>Promise<void|letInstance>} options.importData",
			"* @param {(relativePath:string)=>Promise<void|((...any:any)=>Promise<any>)>} options.importLib",
			"* @param {(path_:string)=>Promise<[letInstance:letInstance, postMessage:(message: any, options?: StructuredSerializeOptions)=>void]>} options.importWorker",
			"* @param {()=>Promise<{resume:()=>void}>} options.qFIFO",
			"* @param {(id:anyButNull)=>Promise<{resume:()=>void}>} options.qUnique",
			"* @returns {Promise<anyButNull>}",
			"* @typedef {derivedFunction|[signalValueType:anyButNull, storeMode?:'sessionStorage'|'localStorage'|undefined]} ",
			"vorthData",
			"* @type {vorthData}",
			"*/",
			"export const data = ${1://code};"
		],
		"description": "StaticVorthData"
	},
	"VorthLib": {
		"scope": "javascript",
		"prefix": ">>lib",
		"body": [
			"// @ts-check",
			"/**",
			"* @type {import('vorth')..vorthLib<(${1:...argumentsTypes})=>Promise<${3:returnType}>>}",
			"*/",
			"export const lib = async (",
			"{${4:...vorthOptions}},",
			"${2:parameters}",
			") => {",
			"\t${0://code}",
			"};"
		],
		"description": "VorthLib"
	},
	"tsVorthLib": {
		"scope": "typescript",
		"prefix": ">>lib",
		"body": [
			"import type { vorthLib } from 'vorth';",
			"",
			"export const lib: vorthLib<(${1:...argumentsTypes})=>Promise<${3:returnType}>> = async (",
			"{${4:...vorthOptions}},",
			"${2:parameters}",
			") => {",
			"\t${0://code}",
			"};"
		],
		"description": "tsVorthLib"
	},
	"StaticVorthLib": {
		"scope": "javascript",
		"prefix": ">>staticLib",
		"body": [
			"// @ts-check",
			"/**",
			"* @typedef {Object} \\$Instance",
			"* @property {()=>void} remove$",
			"* @property {(isAtInitialization:boolean)=>Promise<void>} effect",
			"* @callback \\$__",
			"* @param {(isAtInitialization:boolean)=>Promise<void>} effect",
			"* @returns {\\$_}",
			"* @typedef {Object} letInstance",
			"* @property {any} value",
			"* @property {string|null} attr",
			"* @property {()=>void} call$",
			"* @property {(effect:\\$Instance)=>void} remove$",
			"* @property {()=>void} removeAll$",
			"* @property {()=>void} unRef",
			"* @callback VorthLet",
			"* @param {{dataOnly:any}|{attr:string, data:any}} obj",
			"* @returns {letInstance}",
			"* @typedef {letInstance} derivedInstance",
			"* @callback VorthDerived",
			"* @param {{dataOnly:()=>Promise<any>}|{attr:string, data:()=>Promise<any>}} obj",
			"* @returns {derivedInstance}",
			"* @typedef {HTMLElementEventMap & { vorth: CustomEvent}} ExtendedHTMLElementEventMap",
			"* @typedef {{[K in keyof ExtendedHTMLElementEventMap]? : (K extends 'vorth' ? {listener:  (this: HTMLElement, options:{$:\\$__, let_:VorthLet, derived:VorthDerived, onAttributeChanged:((options:{attr:string, newValue:string})=>Promise<void>), onDisconnected:(arg0:()=>Promise<void>)=>void})=>Promise<void>}: {listener:(this: HTMLElement, ev: ExtendedHTMLElementEventMap[K])=> void, options?:{onAdd?:boolean|AddEventListenerOptions, onRemove?:boolean|EventListenerOptions}})}} selectArg_On",
			"* @callback ForData",
			"* @param {Object} a0",
			"* @param {string} a0.dataName",
			"* @param {string} a0.childLifescycle",
			"* @param {HTMLElement} [a0.element]",
			"* @param {boolean} [a0.waitForOnViewToRender]",
			"* @param {()=>Promise<void>} [a0.afterLoopCallback]",
			"* @returns {Promise<void>}",
			"* @typedef {(handler:()=>Promise<void>)=>void} vorthOnDisconnected",
			"* @typedef {Object} onViewPortHandler",
			"* @property {()=>void} removeOnExitViewCallback",
			"* @property {()=>void} removeOnViewCallback",
			"* @property {()=>void} unobserveElement",
			"* @typedef {Object} elementsLCCallbacks",
			"* @property {(onViewCallbacksOptions: onViewPortHandler) => Promise<void>} onViewCallback",
			"* @property {(onViewCallbacksOptions: onViewPortHandler) => Promise<void>} onExitViewCallback",
			"* @property {vorthOnDisconnected[]} lifecyclesOnDisconnected",
			"* @callback VorthSelect",
			"* @param {string} attributeName",
			"* @param {Object} a0",
			"* @param {selectArg_On} a0.on",
			"* @param {boolean} [a0.waitForOnViewToRender]",
			"* @param {boolean} [a0.isGlobal]",
			"* @returns {{attr:string}}",
			"* @typedef {Object} vorthLifecycleOptions",
			"* @property {(effect:\\$Instance[\"effect\"])=>\\$Instance} $",
			"* @property {(options:{on:selectArg_On, waitForOnViewToRender?:boolean})=>string} attr",
			"* @property {VorthDerived} derived",
			"* @property {HTMLElement} element",
			"* @property {{data:ForData, of:()=>{index:number, value:{[key:string]:string}|undefined}|false}} for_",
			"* @property {(strings:TemplateStringsArray,...values:string[])=>{inner:()=>void, string:string}} html",
			"* @property {(dataName:string)=>Promise<letInstance>} importData",
			"* @property {(libName:string)=>Promise<(...any:any)=>Promise<any>>} importLib",
			"* @property {(workerName:string, sharedSignal?:boolean)=>Promise<[signal:{value:MessageEvent}, postMessage:(message: any, options?: StructuredSerializeOptions)=>void]>} importWorker",
			"* @property {VorthLet} let_",
			"* @property {(lifecycleName:string)=>string} lifecycleAttr",
			"* @property {(events:{[K in keyof HTMLElementEventMap]?: {listener:((this: HTMLElement, ev: HTMLElementEventMap[K])=> void), options?:{onAdd?:boolean|AddEventListenerOptions, onRemove?:boolean|EventListenerOptions}}})=>void} on",
			"* @property {(handler:(options:{attr:string, newValue:string})=>Promise<void>)=>void} onAttributeChanged",
			"* @property {vorthOnDisconnected} onDisconnected",
			"* @property {(elementsCallbacks:elementsLCCallbacks)=>{disconnect:(()=>Promise<void>)}} onViewPort",
			"* @property {()=>{resume:(()=>void)}} qFIFO",
			"* @property {(id:any)=>{resume:(()=>void)}} qUnique",
			"* @property {VorthSelect} select",
			"* @property {(lifecycleName:string, element:HTMLElement, waitForOnViewToRender?:boolean)=>void} triggerLifecycle",
			"* @typedef {(vorthLifecycleOptions:vorthLifecycleOptions, ...any:any)=>Promise<any>} StaticVorthLib",
			"* @type {StaticVorthLib}",
			"*/",
			"export const lib = async ({${1:...vorthLifecycleOptions}}, ${2:...args}) => {",
			"${0:// code;}",
			"};"
		],
		"description": "StaticVorthLib"
	},
	"tsVorthLifecycle": {
		"scope": "typescript",
		"prefix": ">>lifecycle",
		"body": [
			"import type { vorthLifecycle } from 'vorth';",
			"",
			"export const lifecycle: vorthLifecycle = async ({${1:...vorthLifecycleOptions}}) => {",
			"\t${0:// code}",
			"};"
		],
		"description": "tsVorthLifecycle"
	},
	"VorthLifecycle": {
		"scope": "javascript",
		"prefix": ">>lifecycle",
		"body": [
			"// @ts-check",
			"/**",
			"* @type {import('vorth').vorthLifecycle = async ({${1:...vorthLifecycleOptions}})}",
			"*/",
			"export const lifecycle => {",
			"\t${0:// code}",
			"};"
		],
		"description": "VorthLifecycle"
	},
	"StaticVorthLifecycle": {
		"scope": "javascript",
		"prefix": ">>staticLifecycle",
		"body": [
			"// @ts-check",
			"/**",
			"* @typedef {Object} \\$Instance",
			"* @property {()=>void} remove$",
			"* @property {(isAtInitialization:boolean)=>Promise<void>} effect",
			"* @callback \\$__",
			"* @param {(isAtInitialization:boolean)=>Promise<void>} effect",
			"* @returns {\\$_}",
			"* @typedef {Object} letInstance",
			"* @property {any} value",
			"* @property {string|null} attr",
			"* @property {()=>void} call$",
			"* @property {(effect:\\$Instance)=>void} remove$",
			"* @property {()=>void} removeAll$",
			"* @property {()=>void} unRef",
			"* @callback VorthLet",
			"* @param {{dataOnly:any}|{attr:string, data:any}} obj",
			"* @returns {letInstance}",
			"* @typedef {letInstance} derivedInstance",
			"* @callback VorthDerived",
			"* @param {{dataOnly:()=>Promise<any>}|{attr:string, data:()=>Promise<any>}} obj",
			"* @returns {derivedInstance}",
			"* @typedef {HTMLElementEventMap & { vorth: CustomEvent}} ExtendedHTMLElementEventMap",
			"* @typedef {{[K in keyof ExtendedHTMLElementEventMap]? : (K extends 'vorth' ? {listener:  (this: HTMLElement, options:{$:\\$__, let_:VorthLet, derived:VorthDerived, onAttributeChanged:((options:{attr:string, newValue:string})=>Promise<void>), onDisconnected:(arg0:()=>Promise<void>)=>void})=>Promise<void>}: {listener:(this: HTMLElement, ev: ExtendedHTMLElementEventMap[K])=> void, options?:{onAdd?:boolean|AddEventListenerOptions, onRemove?:boolean|EventListenerOptions}})}} selectArg_On",
			"* @callback ForData",
			"* @param {Object} a0",
			"* @param {string} a0.dataName",
			"* @param {string} a0.childLifescycle",
			"* @param {HTMLElement} [a0.element]",
			"* @param {boolean} [a0.waitForOnViewToRender]",
			"* @param {()=>Promise<void>} [a0.afterLoopCallback]",
			"* @returns {Promise<void>}",
			"* @typedef {(handler:()=>Promise<void>)=>void} vorthOnDisconnected",
			"* @typedef {Object} onViewPortHandler",
			"* @property {()=>void} removeOnExitViewCallback",
			"* @property {()=>void} removeOnViewCallback",
			"* @property {()=>void} unobserveElement",
			"* @typedef {Object} elementsLCCallbacks",
			"* @property {(onViewCallbacksOptions: onViewPortHandler) => Promise<void>} onViewCallback",
			"* @property {(onViewCallbacksOptions: onViewPortHandler) => Promise<void>} onExitViewCallback",
			"* @property {vorthOnDisconnected[]} lifecyclesOnDisconnected",
			"* @callback VorthSelect",
			"* @param {string} attributeName",
			"* @param {Object} a0",
			"* @param {selectArg_On} a0.on",
			"* @param {boolean} [a0.waitForOnViewToRender]",
			"* @param {boolean} [a0.isGlobal]",
			"* @returns {{attr:string}}",
			"* @typedef {Object} vorthLifecycleOptions",
			"* @property {(effect:\\$Instance[\"effect\"])=>\\$Instance} $",
			"* @property {(options:{on:selectArg_On, waitForOnViewToRender?:boolean})=>string} attr",
			"* @property {VorthDerived} derived",
			"* @property {HTMLElement} element",
			"* @property {{data:ForData, of:()=>{index:number, value:{[key:string]:string}|undefined}|false}} for_",
			"* @property {(strings:TemplateStringsArray,...values:string[])=>{inner:()=>void, string:string}} html",
			"* @property {(dataName:string)=>Promise<letInstance>} importData",
			"* @property {(libName:string)=>Promise<(...any:any)=>Promise<any>>} importLib",
			"* @property {(workerName:string, sharedSignal?:boolean)=>Promise<[signal:{value:MessageEvent}, postMessage:(message: any, options?: StructuredSerializeOptions)=>void]>} importWorker",
			"* @property {VorthLet} let_",
			"* @property {(lifecycleName:string)=>string} lifecycleAttr",
			"* @property {(events:{[K in keyof HTMLElementEventMap]?: {listener:((this: HTMLElement, ev: HTMLElementEventMap[K])=> void), options?:{onAdd?:boolean|AddEventListenerOptions, onRemove?:boolean|EventListenerOptions}}})=>void} on",
			"* @property {(handler:(options:{attr:string, newValue:string})=>Promise<void>)=>void} onAttributeChanged",
			"* @property {vorthOnDisconnected} onDisconnected",
			"* @property {(elementsCallbacks:elementsLCCallbacks)=>{disconnect:(()=>Promise<void>)}} onViewPort",
			"* @property {()=>{resume:(()=>void)}} qFIFO",
			"* @property {(id:any)=>{resume:(()=>void)}} qUnique",
			"* @property {VorthSelect} select",
			"* @property {(lifecycleName:string, element:HTMLElement, waitForOnViewToRender?:boolean)=>void} triggerLifecycle",
			"* @typedef {(options:vorthLifecycleOptions)=>Promise<void>} StaticVorthLifecycle",
			"* @type {StaticVorthLifecycle}",
			"*/",
			"export const lifecycle = async({ ${1:...vorthLifecycleOptions} })=>{",
			"${0:// code;}",
			"};"
		],
		"description": "StaticVorthLifecycle"
	}
}
