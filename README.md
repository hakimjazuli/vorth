- this is a placeholder for client side router & renderer library made using [virst](https://www.npmjs.com/package/virst) `Lifecycle`;
- until later stable release of vorth, the documentation will be minimal;
## documentation for signal
refer to [virst](https://www.npmjs.com/package/virst):
- [Let](https://www.npmjs.com/package/virst#let) for exported `data.let`, only support dataOnly;
- [Derived](https://www.npmjs.com/package/virst#derived) for derived function `data.derived`, only support dataOnly;
- [$](https://www.npmjs.com/package/virst#$) for `$` as in `effect`;
## type-helper
- [Vorth](#vorth)
- [__vorthApp](#__vorthapp)
<h2 id="vorth">Vorth</h2>

how to use:- download the `prebundled.mjs`, and load it on your html:```html<script type="module" src="/your/vort_root/path/prebundled.mjs"></script>```- add `vorth` and `your/relative/path/module` as `attribute` on the element:```html<div vorth="your/relative/path/module"></div>```- `vorthLifecycle`: paste this type helper on `/your/vort_root/path/lifecycles/your/relative/path/module.mjs`(the `lifecycles/` is fixed path):```js/*** @typedef {(...args:any)=>Promise<any>} importedLib* @typedef {Record<string, any>|Array|string|number|boolean} returnOfSignal* @typedef {{value:returnOfSignal,call$:()=>void,remove$:(effect:{effect:()=>void})=>void}} signalRef_* @typedef {Object} onViewPortInstance* @property {() => Promise<void>} disconnect* @property {(element: Element | HTMLElement) => onViewPortHandler} handlers* @typedef {Object} onViewPortHandler* @property {()=>void} removeOnExitViewCallback* @property {()=>void} removeOnViewCallback* @property {()=>void} unobserveElement* @typedef {(isAtInitialization:boolean)=>Promise<void>} effectCallback* @typedef {Object} elementsLCCallbacks* @property {(onViewCallbacksOptions: onViewPortHandler) => Promise<void>} onViewCallback* @property {(onViewCallbacksOptions: onViewPortHandler) => Promise<void>} onExitViewCallback* @property {mrefOptions["onDisconnected"][]} lifecyclesOnDisconnected* @typedef {Object} mrefOptions* @property {HTMLElement} element* @property {boolean} isConnected* @property {(strings:TemplateStringsArray,...values:string[])=>void} html* - control innerHTML using `templateLiteral`;* @property {(arg0:(options:{attributeName:string, newValue:string})=>Promise<void>)=>void} onAttributeChanged* @property {(arg0:()=>Promise<void>)=>void} onDisconnected* @property {(elementsCallbacks:elementsLCCallbacks)=>onViewPortInstance} onViewPort* @property {(effect:effectCallback)=>{effect:effectCallback}} $* - to create `effect` on data changes;* @property {(relativePath:string)=>Promise<signalRef_|false>} importData* @property {(relativePath:string)=>Promise<importedLib|false>} importLib* @property {(options:{dataOnly:returnOfSignal}|{attributeName:string, data:returnOfSignal})=>signalRef_|false} let_* @property {(options:{dataOnly:()=>Promise<returnOfSignal>}|{attributeName:string, data:()=>Promise<returnOfSignal>})=>signalRef_|false} derived* @property {string} loopedAttrName* @property {()=>{[key:string]:string}} parsedLoopedAttr* @property {(options:{signal:signalRef_, childLifescyclePath:string, afterLoopCallback?:()=>Promise<void>,element?:HTMLElement})=>void} for_* @typedef {(mrefOptions:mrefOptions)=>Promise<void>} vorthLifecycle*//** @type {vorthLifecycle} */export default async ( { ...options /** replace ...option with properties that you need;  */ } )=>{	// your js code;}```> - for `onDisconnected` `event`, there's no need for manual clean-up on `let_` and `derived`, as both are automatically `unRefed`, when this `event` is triggered;> - `for_`:> > - `element` if not filled will refer to current `lifecycle` `element`;> > - `signal` `value` `type` should be `{[key:string]:string}[]`;> - `html` method can be called using html\`yourHMTLLiteral\`;> - recommended to install `lit-plugin` in vs-code for syntax highlighting;> - in real `runtime` the path will be something like:> > - `/assets/js/modules/lifecycles/my_module.mjs`;> > - `/assets/js/modules/data/my_data.mjs`;- `vorthData`: for data layer, on the `/your/vort_root/path/data/your/relative/path/signal.mjs`(the `data/` is fixed path):```js/*** @typedef {{value:any,call$:()=>void,remove$:(effect:{effect:()=>void})=>void}} signalRef__* @typedef {{data:{let:Record<string, any>|Array|string|number|boolean},storeMode:false|'localStorage'|'sessionStorage'}|{data:{derived:((a0:{importData:(relativePath:string)=>Promise<signalRef__|false>,importLib:(relativePath:string)=>Promise<((...args:any)=>Promise<any>)|false>})=>Promise<Record<string, any>|Array|string|number|boolean>)}}} vorthData*//** @type {vorthData} */export default { storeMode: false, data: {...option} }```> - which you can reference with `mrefOptions.signalRef` on the relative path it's pointing to;> - the destructured { value } returned from `mrefOptions.signalRef`, can be reassigned to trigger `changes`, except the endpoint that are `derived`;> - in the `mrefOptions.$`, you can reference return value of `mrefOptions.signalRef`, to create `effects`, which is a `callback` that will be called everytime there's `changes` on the value of that `reference` called in the `$` `callback` parameter, unless it's nested value like array(using array modification method) or object, in wich you need to fire `call$` in the element lifecyle, unless you want to use reassignment syntax using spreading operator;```js// in vorthLifecycle scopeconst signal = let_([1,2,3]); // or from signalRef;signal.value.push(4);signal.call$();// will have the same effect ofsignal.value = [ ...signal.value, 1 ];// the spreading operator also works on object type// const signal = let_({ data1:'1', data2:'2' }); // or from signalRef;// signal.value = { ...signal.value, newKey:'value' };$(async (isAtInitialization) => {	const value = signal.value;	// if (isAtInitialization) {	//	return;	// } // uncomment this to stop any further signal autosubscribing bellow this point	console.console.log(value);});```- `vorthLib`: for data layer, on the `/your/vort_root/path/libs/your/relative/path/lib.mjs`(the `libs/` is fixed path):```js/*** @typedef {(...args:any)=>Promise<any>} vorthLib*//** @type {vorthLib} */export default async () => {	// js code}```> - which you can use by using `importLib` on multiple `lifecycle` or `derived` `data`;

*) <sub>[go to exported list](#type-helper)</sub>

<h2 id="__vorthapp">__vorthApp</h2>

for developer who want to use package managers:- download the `prebundled.mjs`, and load it on your html:```html<script type="module" src="/target/path/prebundled.mjs"></script>```- you can instantiate this class to monitor directory;```js// /dev/vorth.mjs// @ts-checkimport { __vorthApp } from 'vorth/src/__vorthApp.mjs'; // the main `vorth` got poluted with `Vorth` which refer to browser window;new __vorthApp('source/path', 'target/path');```- inside `source/path` do this:> - place downloaded `./prebundled.mjs`;> - create dir:> > - `./lifecycles`;> > - `./data`;> > - `./libs`;- add runner script to `package.json` `script`;```json{	...	"scripts":{		...		"myscript" : "node ./dev/vorth.mjs",		...	},	...}```- run by calling `myscript` on terminal using packageManager;```bashnpm run myscript;```- instead of copy pasting type helper from this README.md you can use exported type of `vorth` for the respective `modules`;```ts// typescriptimport type { vorthData, vorthLib, vorthLifecycle } from 'vorth';const module_ : vorthData = {};export default module_``````js// mjs with jsdoc// @ts-check/*** @typedef {import('vorth').vorthData} vorthData* @typedef {import('vorth').vorthLib} vorthLib* @typedef {import('vorth').vorthLifecycle} vorthLifecycle* @type {vorthData}*/export default {};```

*) <sub>[go to exported list](#type-helper)</sub>
